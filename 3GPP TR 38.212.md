# 5G NR Multiplexing and channel coding
---
Input: MAC PDU (bytes)                                          
        ↓
┌──────────────────────────────┐
│ CRC 附加 (crc_byte.c)         │    
│ Output: bits + CRC           │    5.1 CRC calculation
└────────────┬─────────────────┘
             ↓
┌──────────────────────────────┐
│ Physical-layer HARQ processing │
│ Output: encoded bits         │
└────────────┬─────────────────┘
             ↓
┌──────────────────────────────┐
│ Segmentation (nr_segmentation.c) │  5.2 Code block segmentation and code block CRC attachment
│ Output: LDPC segments (bits) │
└────────────┬─────────────────┘
             ↓
┌──────────────────────────────┐
│ LDPC 編碼 (nr_dlsch_coding.c + CODING/) │   5.2.2 Low density parity check coding
│ Output: encoded bits         │
└────────────┬─────────────────┘
             ↓
┌──────────────────────────────┐
│ Rate Matching + Interleaving │   6.2.5 Rate Matching
│ Output: RM bits              │
└────────────┬─────────────────┘
             ↓
┌──────────────────────────────┐
│ Scrambling                   │
│ Output: RM bits              │
└────────────┬─────────────────┘
             ↓
┌──────────────────────────────┐
│ 調變 (Modulation: QPSK, 16QAM) │
│ Output: complex symbols (IQ) │
└────────────┬─────────────────┘
             ↓
┌──────────────────────────────┐
│ Resource Grid Mapping │
│ Output: complex symbols (IQ) │
└────────────┬─────────────────┘
             ↓
┌──────────────────────────────┐
│ Insert DMRS (UE uplink reference signal) │
│ Output: complex symbols (IQ) │
└────────────┬─────────────────┘
             ↓
┌──────────────────────────────┐
│ DFT-s-OFDM IFFT + CP 加入 (ofdm_mod.c) │
│ Output: time-domain samples │
└────────────┬─────────────────┘
             ↓
┌──────────────────────────────┐
│ 模擬通道:  │
│ Input: TX samples            │
│ Output: RX samples           │
└────────────┬─────────────────┘
             ↓






## CH4 Mapping to physical channels 
- Uplink
  
| Transport Channel (TrCH) | 對應 Physical Channel                   |
| ------------------------ | ------------------------------------- |
| UL-SCH（Uplink-Share Channel)           | PUSCH（Physical Uplink Shared Channel） |
| RACH（Random Access Channel）             | PRACH（Physical Random Access Channel） |

-Downlink

| Transport Channel (TrCH) | 對應 Physical Channel                     |
| ------------------------ | --------------------------------------- |
| DL-SCH（Downlink-Share Channel)           | PDSCH（Physical Downlink Shared Channel） |
| BCH（Broadcast Channel）                | PBCH（Physical Broadcast Channel）        |

## CH5 General procedures
- Channel coding scheme is a combination of error detection, error correcting, rate matching,
interleaving and transport channel or control information mapping onto/splitting from physical channels.

### 5.1 CRC calculation 
- Systematic Form 編碼：資料原樣保留，CRC 附加在後面。
- The parity bits are generated by one of
the following cyclic generator polynomials: 
  ![image](https://github.com/user-attachments/assets/4bbee2e3-d5fb-4182-a2dd-5f486e6772bc)

- 把輸入資料 bits 看成一個多項式：
![image](https://github.com/user-attachments/assets/17923298-a7ba-4fcb-8a21-aedbbe89f418)

把資料往左平移 L 位（預留空間給 CRC）除以g(x)取出餘數（R(x)），作為 parity bits（CRC）
最終送出資料為：
![image](https://github.com/user-attachments/assets/feeb794b-9659-4057-82bf-a83733cc7c21)

- 傳送端依據上述方式產生 parity bits 並附加於資料後
- 接收端重做整個多項式除法： T(x)mod g(x)
   - 若餘數為 0 → 資料無誤
   - 若餘數 ≠ 0 → 有錯誤
### 5.2 Code block segmentation and code block CRC attachment
#### 5.2.2 Low density parity check coding
| Base Graph | 最大 code block 長度 $K_{cb}$ |
| ---------- | ------------------------- |
| BG1        | 8448 bits                 |
| BG2        | 3840 bits                 |
- STEP1: if B > Kcb
  - 要將資料分成 C 段 code block
  - 每段後面加上 L = 24 bits 的 CRC24B
- else
  - C = 1
  - 不加 CRC（L = 0）       
  - B'= B
- STEP2:  C=⎡B/(Kcb−24)⎤←ceiling(無條件進位)B′=B+24×C←加上所有CRCbits後的總長度
  - 每段 block 的總長度： 𝐾=𝐵′/𝐶，而實際進入 LDPC 編碼的是前面 K'=K-24(CRC長度)
- STEP3: 找到最小的Z滿足 Z×Kb≥K′ ，
  - BG1-> Kb=22 
  - BG2->
    
| BG2 條件     | Kb 值 |
| ------------ | ---- |
| B > 640      | 10   |
| 560 < B ≤640 | 9    |
| 192 < B ≤560 | 8    |
| B ≤192       | 6    |

![image](https://github.com/user-attachments/assets/b5226c6a-bd58-4050-bbcb-b2b010cf4af2)
從此表找到Zc，也能找到iLs
![image](https://github.com/user-attachments/assets/5ebb2d9d-1e65-4387-bfe2-8d3fe7c6ec3a)
- STEP4: 以BG、iLs找到對應的HBG矩陣，每個都很大，BG1為例，HBG是46*68的矩陣，每個元素要再展開成Zc*Zc的單位矩陣，而此數字表示位移的次數，
- STEP5: 以Zc為例，最終得到一個大小為 46×384 行 × 68×384 列（共 17664 × 26112）的矩陣H。
- STEP6: 定義 codeword bit 向量：d=[do,d1,...d26111]，輸入資料C=8448bits，會從d的2*384位元開始塞
- codeword d[0:26111] = [ d[0] ~ d[767] ]-----[ d[768] ~ d[9215] ]-----[ d[9216] ~ d[26111] ]<br>
--------------------------↑ Parity bits ↑-----↑ c[0] ~ c[8447] ↑------↑ 剩下是 padding（NULL)↑

​- STEP7:要滿足：H⋅d^T=0
 - 實際做法：把 H 分為兩部分：H=[Hp∣Hs]
   - Hp：前 768 個 columns（parity bits）
   - Hs：後 8448 個 columns（data bits）
   - 把資料部分代入後，解：Hp ⋅ W^T=Hs ⋅ C^T => W=(Hp^-1) ⋅ (Hs ⋅ C^T)
   - W=[w0...w767]=[d0...d767]  (實務上不會直接求 inverse，而是用高斯消去或類似法，OAI實作為XOR加總）
### 5.4 Rate matching
#### 5.4.2 Rate Matching for LDPC Code
Rate Matching 適用於每一個 LDPC 編碼後的 code block
- 1. Bit Selection
輸入：LDPC 編碼產生的 bit 序列 d[0] ...d[N-1]，將 d 寫入一個長度為 Ncb 的 circular buffer，如果 LBRM = 0，則 Ncb = N，否則 Ncb = min(N, Nref)
** Nref 根據 base graph、TBS、layer 數、modulation order、coding rate 等條件計算（見 TS 38.214）
- 2. Bit Interleaving
  - 將 E 個選出的 bits e[0] ~ e[E-1] 做 interleaving，得到 f[0] ~ f[E-1]
  - 根據 modulation order Qm（例如 QPSK=2, 16QAM=4, 64QAM=6, 256QAM=8）進行順序打亂
## CH6 Uplink transport channels and control information
### 6.2 Uplink shared channel 
#### 6.2.2 LDPC Base Graph 選擇
- 依據 payload 大小 A（含 CRC） 與 code rate R（由 MCS 決定）選擇 Base Graph：
  使用 Base Graph 2（BG2） 的條件：
  - A ≤ 292，或
  - A ≤ 3824 且 R ≤ 0.67，或
  - R ≤ 0.25，
否則使用 Base Graph 1（BG1）
#### 6.2.5 Rate Matching
- 輸入：d₀^{(r)}, ..., d_{N_r -1}^{(r)}
  - 每個 CB 獨立進行 Rate Matching（參考 5.4.2）
  - 根據高層參數 rateMatching 決定是否啟用 Limited Buffer Rate Matching（LBRM）
  - rateMatching = limitedBufferRM ⇒ I_LBRM = 1
  - 否則 I_LBRM = 0
- 輸出：f₀^{(r)}, ..., f_{E_r -1}^{(r)}（每個 CB 經過匹配後為 E_r 個位元）
```
Transport Block (B bits, 含CRC)
        ↓
[6.2.3] Code Block 分段 + CB CRC
        ↓
[6.2.4] LDPC 編碼（每個 CB）
        ↓
[6.2.5] Rate Matching（每個 CB）
        ↓
[6.2.6] CB 合併（Concatenation）
        ↓
最終上行傳送位元 g₀, ..., g_{G-1}
```
#### 6.2.7 Data and control multiplexing 
- 在 PUSCH 將（UL-SCH）和控制信息（HARQ-ACK、CSI、CG-UCI）MIX成一個編碼比特序列，並分配到 OFDM 符號和子載波的資源元素上。
- 考慮了以下因素：
  - frequency hopping
    ![image](https://github.com/user-attachments/assets/47360570-d41b-415b-8c1c-ea8a58e22de3)
  - DMRS 符號的影響（不攜帶 UCI）。
  - 控制信息的優先級（如 HARQ-ACK 比 CSI 優先）。
    ![image](https://github.com/user-attachments/assets/1bc23d8e-7e2c-460c-a125-1a99716e969c)
  - 調製階數 Qm 和傳輸層數 NL 的影響。
    ![image](https://github.com/user-attachments/assets/56a0c142-6baa-4cc4-8c59-1a36fd9fef92)
- 分成6個STEP:
  - Step 1: 初始化資源集合與預留 HARQ-ACK 資源
  - Step 2：優先處理 HARQ-ACK（或與 CG-UCI 聯合編碼），分配 UCI 資源。
  - Step 2A：處理單獨的 CG-UCI，分配 UCI 資源。
  - Step 3：依次處理 CSI Part 1 和 Part 2，分配剩餘 UCI 資源。
  - Step 4：將 UL-SCH 數據映射到剩餘的 UL-SCH 資源。
  - Step 5：處理少量 HARQ-ACK（≤ 2 比特），使用預留資源。
  - Step 6：生成最終的序列，完成所有位元的映射。
 
    
